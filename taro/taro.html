<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taro Emulator</title>
    <link rel="icon" href="data:,">
    <style>
        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eee;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="1280" height="960" style="border: 2px solid black;"></canvas>
    <script type="module">
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const FRAMEBUFFER_WIDTH = 320;
        const FRAMEBUFFER_HEIGHT = 480;

        const framebuffer = ctx.createImageData(canvas.width, canvas.height);

        const { instance } = await WebAssembly.instantiateStreaming(fetch('taro.wasm'));
        const vram = new DataView(instance.exports.memory.buffer);

        function degrees(radians) {
            return radians * (180 / Math.PI);
        }

        function radians(degrees) {
            return degrees * (Math.PI / 180);
        }

        class Vector4 {
            constructor(x = 0, y = 0, z = 0, w = 1) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }

            clone() {
                return new Vector4(this.x, this.y, this.z, this.w);
            }

            add(rhs) {
                if (rhs instanceof Vector4) {
                    this.x += rhs.x;
                    this.y += rhs.y;
                    this.z += rhs.z;
                    this.w += rhs.w;
                }
            }

            mul(rhs) {
                if (rhs instanceof Matrix4) {
                    const x = rhs.elements[0 * 4 + 0] * this.x + rhs.elements[1 * 4 + 0] * this.y + rhs.elements[2 * 4 + 0] * this.z + rhs.elements[3 * 4 + 0] * this.w;
                    const y = rhs.elements[0 * 4 + 1] * this.x + rhs.elements[1 * 4 + 1] * this.y + rhs.elements[2 * 4 + 1] * this.z + rhs.elements[3 * 4 + 1] * this.w;
                    const z = rhs.elements[0 * 4 + 2] * this.x + rhs.elements[1 * 4 + 2] * this.y + rhs.elements[2 * 4 + 2] * this.z + rhs.elements[3 * 4 + 2] * this.w;
                    const w = rhs.elements[0 * 4 + 3] * this.x + rhs.elements[1 * 4 + 3] * this.y + rhs.elements[2 * 4 + 3] * this.z + rhs.elements[3 * 4 + 3] * this.w;
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                }
                return this;
            }

            div(rhs) {
                if (!isNaN(rhs)) {
                    this.x /= rhs;
                    this.y /= rhs;
                    this.z /= rhs;
                    this.w /= rhs;
                }
                return this;
            }
        }

        class Matrix4 {
            constructor(elements) {
                this.elements = elements;
            }

            clone() {
                return new Matrix4(this.elements);
            }

            mul(matrix) {
                const b00 = matrix.elements[0 * 4 + 0];
                const b01 = matrix.elements[0 * 4 + 1];
                const b02 = matrix.elements[0 * 4 + 2];
                const b03 = matrix.elements[0 * 4 + 3];
                const b10 = matrix.elements[1 * 4 + 0];
                const b11 = matrix.elements[1 * 4 + 1];
                const b12 = matrix.elements[1 * 4 + 2];
                const b13 = matrix.elements[1 * 4 + 3];
                const b20 = matrix.elements[2 * 4 + 0];
                const b21 = matrix.elements[2 * 4 + 1];
                const b22 = matrix.elements[2 * 4 + 2];
                const b23 = matrix.elements[2 * 4 + 3];
                const b30 = matrix.elements[3 * 4 + 0];
                const b31 = matrix.elements[3 * 4 + 1];
                const b32 = matrix.elements[3 * 4 + 2];
                const b33 = matrix.elements[3 * 4 + 3];
                const a00 = this.elements[0 * 4 + 0];
                const a01 = this.elements[0 * 4 + 1];
                const a02 = this.elements[0 * 4 + 2];
                const a03 = this.elements[0 * 4 + 3];
                const a10 = this.elements[1 * 4 + 0];
                const a11 = this.elements[1 * 4 + 1];
                const a12 = this.elements[1 * 4 + 2];
                const a13 = this.elements[1 * 4 + 3];
                const a20 = this.elements[2 * 4 + 0];
                const a21 = this.elements[2 * 4 + 1];
                const a22 = this.elements[2 * 4 + 2];
                const a23 = this.elements[2 * 4 + 3];
                const a30 = this.elements[3 * 4 + 0];
                const a31 = this.elements[3 * 4 + 1];
                const a32 = this.elements[3 * 4 + 2];
                const a33 = this.elements[3 * 4 + 3];

                this.elements = [
                    b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                    b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                    b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                    b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                    b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                    b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                    b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                    b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                    b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                    b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                    b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                    b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                    b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                    b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                    b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                    b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
                ];
                return this;
            }

            static identity() {
                return new Matrix4([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }

            static perspective(fov, aspect, near, far) {
                const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
                const r = 1.0 / (near - far);
                return new Matrix4([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * r, -1,
                    0, 0, near * far * r * 2, 0
                ]);
            }

            static translate(x, y, z) {
                return new Matrix4([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    x, y, z, 1
                ]);
            }

            static rotateX(x) {
                const c = Math.cos(x);
                const s = Math.sin(x);
                return new Matrix4([
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ]);
            }

            static rotateY(y) {
                const c = Math.cos(y);
                const s = Math.sin(y);
                return new Matrix4([
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ]);
            }

            static rotateZ(z) {
                const c = Math.cos(z);
                const s = Math.sin(z);
                return new Matrix4([
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }

            static scale(x, y, z) {
                return new Matrix4([
                    x, 0, 0, 0,
                    0, y, 0, 0,
                    0, 0, z, 0,
                    0, 0, 0, 1
                ]);
            }
        }

        const TARO_CMD_OFFSET = 0;
        const CRATE_TEXTURE_OFFSET = TARO_CMD_OFFSET + 0x10000;
        const FRAMEBUFFER_OFFSET = CRATE_TEXTURE_OFFSET + (64 * 64 * 2);

        const CMD_DONE = 0;
        const CMD_SET_FRAMEBUFFER = 1;
        const CMD_SET_CLIP = 2;
        const CMD_CLEAR = 3;
        const CMD_TRIANGLE = 4;
        const CMD_TRIANGLE_TEXTURED = 5;

        function parseOBJ(objText) {
            const lines = objText.split('\n');
            const vertices = [];
            const texCoords = [];
            const normals = [];
            let faces = [];
            const groups = [];

            let currentColor = [0, 0, 0];

            for (const line of lines) {
                const tokens = line.trim().split(/\s+/);
                const keyword = tokens[0];

                switch (keyword) {
                    case 'usemtl':
                        currentColor = tokens.slice(1).map(parseFloat);
                        break;
                    case 'v':
                        vertices.push(tokens.slice(1).map(parseFloat));
                        break;
                    case 'vt':
                        texCoords.push(tokens.slice(1).map(parseFloat));
                        break;
                    case 'vn':
                        normals.push(tokens.slice(1).map(parseFloat));
                        break;
                    case 'f':
                        const face = tokens.slice(1).map((vertexDesc) => {
                            const components = vertexDesc.split('/');
                            const vertexIndex = parseInt(components[0]) - 1;
                            const texCoordIndex = components[1] ? parseInt(components[1]) - 1 : undefined;
                            const normalIndex = components[2] ? parseInt(components[2]) - 1 : undefined;
                            return { vertexIndex, texCoordIndex, normalIndex, currentColor };
                        });
                        faces.push(face);
                        break;
                }
            }
            return { faces, vertices, texCoords, normals };
        }

        const obj = parseOBJ(await(await fetch('police.obj')).text());

        const crateImage = new Image();
        crateImage.src = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNEBCAgICAkICQoKCQ0ODA4NExEQEBETHBQWFBYUHCsbHxsbHxsrJi4lIyUuJkQ1Ly81RE5CPkJOX1VVX3dxd5yc0f/CABEIAEAAQAMBIgACEQEDEQH/xAAwAAACAwEBAAAAAAAAAAAAAAADBAECBQAGAQADAQEAAAAAAAAAAAAAAAAAAQIDBP/aAAwDAQACEAMQAAAA8cNkPF1mrogQk3k7DAbaTsvzFDK3O+mwtneVZg2kazEL53kmLNIvAqjO1k3GRRJ0HKUTR14GznlDBQiLwf/EADUQAAICAQIDAgwFBQAAAAAAAAECAxEABBITITFBUQUUIiMyYWJxgaGxwSRykbLRM0JDUsL/2gAIAQEAAT8A1TlOCwjsuOg78j1NAk6Z/wBFPX44J/JJ8Teq9LkD9cbUbKPAmCjr069e/G8IAPR085J9Yw6uaNSDDL07gfviyFxb6ebr1AX5c80civFIVWRabbTeoXea7a7aNfarN1mqoblywIgWNA5M/EgcCvSX6ZKSXUD/AFGSapNyIBv7KurOREk0UBrmazwbJvi1TP5Pnu38ozXMv4dbIPFv4VhlQkA9BIublMEabOi3mqfZpJCFABMYGKHdBI9bdvQ9uadJWkB9dcsRFfh7CqR7KHtVmiAYaobf8xFH8o554RR9sAaq4xojnZo48J27gf7lrAQsDKeuw884TTaYcQHhWG9+0ZMTJagdB5K9wyOHZAhckB3ANdowlIxGsYrzZo+u8005V9QL5mZv2jJgzamKMdmoNfEHBHUSo689/XEhUq1m0C1fecklk4YRfTAoAcgM19hCie9z1LX9s1TNLpYEo8m+QGQaxXcLIKtWPyGaE8SScoDu4h/bh0rQa2J5D5PHPusg5q5oFbZtNLzsdpx5aRFVeVdOnXtOOfMUhPprz7765qRxeKipz2hryYIkcVHs5jAbnRiTflCh0rPBOweMix/V/W1zXHc8BZzsE/2PXNTwUiWFFBAa+fW+84Y3rbu9Km7t2O21I172Q45uWR+6Nfrmuao4romsih3auPmL2ub7DyGaGFEfU76sTf8AOalGnYWzr53dYrG0s4a+PIPfX8YdDI1F9RIaodmNoSeXjMhqu49Mi8HBtwfUyAEUen8ZLo1cqPGpjtHs19M8VlEkT8eT2arlfwyBNgmVixZpN4dq61Wf/8QAHREAAgMAAgMAAAAAAAAAAAAAAAERITFBUQJSwf/aAAgBAgEBPwDgkfFHlgsQvpJsnRB6jpMUVZK7KlWPNP/EABwRAAEEAwEAAAAAAAAAAAAAAAABIUFREBFxgf/aAAgBAwEBPwDCS4hKimsWbLJPB6HcTh//2Q==';
        crateImage.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = crateImage.width;
            canvas.height = crateImage.height;
            ctx.drawImage(crateImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            let pos = CRATE_TEXTURE_OFFSET;
            for (let i = 0; i < imageData.height * imageData.width; i++) {
                vram.setUint16(pos, ((imageData.data[i * 4 + 0] >> 3) |
                    ((imageData.data[i * 4 + 1] >> 2) << 5) |
                    ((imageData.data[i * 4 + 2] >> 3) << 11)), true);
                pos += 2;
            }

            loop();
        };


        let rotation = 0;
        let police = { position: new Vector4(0, 2, -6), angle: 0 };

        const keys = {};
        window.addEventListener('keydown', event => keys[event.key] = true);
        window.addEventListener('keyup', event => keys[event.key] = false);

        function update() {
            rotation += 1;

            const speed = 0.1;
            const change = new Vector4();
            if (keys['w']) change.z -= speed;
            if (keys['a']) police.angle -= radians(2);
            if (keys['d']) police.angle += radians(2);
            if (keys['s']) change.z += speed;
            police.position.add(change.mul(Matrix4.rotateY(-police.angle)));
        }

        function render() {
            let pos = TARO_CMD_OFFSET;

            vram.setUint8(pos++, CMD_SET_FRAMEBUFFER);
            vram.setUint32(pos, FRAMEBUFFER_OFFSET, true); pos += 4;
            vram.setUint16(pos, FRAMEBUFFER_WIDTH, true); pos += 2;

            vram.setUint8(pos++, CMD_SET_CLIP);
            vram.setUint16(pos, 0, true); pos += 2;
            vram.setUint16(pos, 0, true); pos += 2;
            vram.setUint16(pos, FRAMEBUFFER_WIDTH - 1, true); pos += 2;
            vram.setUint16(pos, FRAMEBUFFER_HEIGHT - 1, true); pos += 2;

            vram.setUint8(pos++, CMD_CLEAR);
            vram.setUint16(pos, (31 | (63 << 5) | (0 << 11)), true); pos += 2;

            const camera = Matrix4.perspective(radians(45), 4 / 3, 0.1, 1000)
                .mul(Matrix4.translate(0, 0, -2));

            {
                const matrix = Matrix4.translate(0, -0.5, -2)
                    .mul(Matrix4.rotateX(-Math.PI / 2))
                    .mul(Matrix4.scale(3, 3, 1));

                // Triangle 1
                vram.setUint8(pos++, CMD_TRIANGLE_TEXTURED);
                vram.setUint32(pos, CRATE_TEXTURE_OFFSET, true); pos += 4;
                vram.setUint8(pos++, 64);

                let vertice0 = new Vector4(-0.5, -0.5, 0).mul(matrix).mul(camera);
                vram.setUint16(pos, (vertice0.x / vertice0.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setUint16(pos, (-vertice0.y / vertice0.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, 0xffff, true); pos += 2;
                vram.setUint8(pos++, 0);
                vram.setUint8(pos++, 0);

                let vertice1 = new Vector4(0.5, -0.5, 0).mul(matrix).mul(camera);
                vram.setUint16(pos, (vertice1.x / vertice1.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setUint16(pos, (-vertice1.y / vertice1.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, 0xffff, true); pos += 2;
                vram.setUint8(pos++, 64);
                vram.setUint8(pos++, 0);

                let vertice2 = new Vector4(0.5, 0.5, 0).mul(matrix).mul(camera);
                vram.setUint16(pos, (vertice2.x / vertice2.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setUint16(pos, (-vertice2.y / vertice2.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, 0xffff, true); pos += 2;
                vram.setUint8(pos++, 64);
                vram.setUint8(pos++, 64);

                // Triangle 2
                vram.setUint8(pos++, CMD_TRIANGLE_TEXTURED);
                vram.setUint32(pos, CRATE_TEXTURE_OFFSET, true); pos += 4;
                vram.setUint8(pos++, 64);

                vertice0 = new Vector4(-0.5, -0.5, 0).mul(matrix).mul(camera);
                vram.setUint16(pos, (vertice0.x / vertice0.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setUint16(pos, (-vertice0.y / vertice0.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, 0xffff, true); pos += 2;
                vram.setUint8(pos++, 0);
                vram.setUint8(pos++, 0);

                vertice1 = new Vector4(0.5, 0.5, 0).mul(matrix).mul(camera);
                vram.setUint16(pos, (vertice1.x / vertice1.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setUint16(pos, (-vertice1.y / vertice1.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, 0xffff, true); pos += 2;
                vram.setUint8(pos++, 64);
                vram.setUint8(pos++, 64);

                vertice2 = new Vector4(-0.5, 0.5, 0).mul(matrix).mul(camera);
                vram.setUint16(pos, (vertice2.x / vertice2.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setUint16(pos, (-vertice2.y / vertice2.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, 0xffff, true); pos += 2;
                vram.setUint8(pos++, 0);
                vram.setUint8(pos++, 64);
            }


            // const matrix = Matrix4.translate(0, 0, -5)
            //     .mul(Matrix4.rotateX(radians(rotation)))
            //     .mul(Matrix4.rotateY(radians(rotation)))
            //     .mul(Matrix4.scale(1, 1, 1));

            const matrix = Matrix4.translate(police.position.x, police.position.y, police.position.z)
                .mul(Matrix4.rotateX(radians(180)))
                .mul(Matrix4.rotateY(police.angle));

            function faceDepth(face, vertices, matrix, camera) {
                const a = new Vector4(vertices[face[0].vertexIndex][0], vertices[face[0].vertexIndex][1], vertices[face[0].vertexIndex][2])
                    .mul(matrix).mul(camera);
                const b = new Vector4(vertices[face[1].vertexIndex][0], vertices[face[1].vertexIndex][1], vertices[face[1].vertexIndex][2])
                    .mul(matrix).mul(camera);
                const c = new Vector4(vertices[face[2].vertexIndex][0], vertices[face[2].vertexIndex][1], vertices[face[2].vertexIndex][2])
                    .mul(matrix).mul(camera);
                return a.z + b.z + c.z;
            }

            obj.faces.sort((a, b) => {
                return faceDepth(b, obj.vertices, matrix, camera) -
                    faceDepth(a, obj.vertices, matrix, camera);
            });

            for (const face of obj.faces) {
                vram.setUint8(pos++, CMD_TRIANGLE);

                const faceColor = Math.floor(face[0].currentColor[0] * 31) |
                    (Math.floor(face[0].currentColor[1] * 63) << 5) |
                    (Math.floor(face[0].currentColor[2] * 31) << 11);

                const vertice0 = new Vector4(obj.vertices[face[0].vertexIndex][0], obj.vertices[face[0].vertexIndex][1], obj.vertices[face[0].vertexIndex][2])
                    .mul(matrix).mul(camera);
                vram.setInt16(pos, (vertice0.x / vertice0.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setInt16(pos, (vertice0.y / vertice0.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, faceColor, true); pos += 2;

                const vertice1 = new Vector4(obj.vertices[face[1].vertexIndex][0], obj.vertices[face[1].vertexIndex][1], obj.vertices[face[1].vertexIndex][2])
                    .mul(matrix).mul(camera);
                vram.setInt16(pos, (vertice1.x / vertice1.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setInt16(pos, (vertice1.y / vertice1.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, faceColor, true); pos += 2;

                const vertice2 = new Vector4(obj.vertices[face[2].vertexIndex][0], obj.vertices[face[2].vertexIndex][1], obj.vertices[face[2].vertexIndex][2])
                    .mul(matrix).mul(camera);
                vram.setInt16(pos, (vertice2.x / vertice2.w + 1) * (FRAMEBUFFER_WIDTH >> 1), true); pos += 2;
                vram.setInt16(pos, (vertice2.y / vertice2.w + 1) * (FRAMEBUFFER_HEIGHT >> 1), true); pos += 2;
                vram.setUint16(pos, faceColor, true); pos += 2;
            }

            vram.setUint8(pos++, CMD_DONE);
        }

        function loop() {
            update();
            render();

            instance.exports.clock(TARO_CMD_OFFSET);

            const scaleX = Math.floor(framebuffer.width / FRAMEBUFFER_WIDTH);
            const scaleY = Math.floor(framebuffer.height / FRAMEBUFFER_HEIGHT);
            for (let y = 0; y < FRAMEBUFFER_HEIGHT; y++) {
                for (let x = 0; x < FRAMEBUFFER_WIDTH; x++) {
                    const color = vram.getUint16(FRAMEBUFFER_OFFSET + (y * FRAMEBUFFER_WIDTH + x) * 2, true);
                    for (let ry = 0; ry < scaleY; ry++) {
                        for (let rx = 0; rx < scaleX; rx++) {
                            const dest = ((y * scaleY + ry) * framebuffer.width + (x * scaleX + rx)) * 4;
                            framebuffer.data[dest] = (color & 31) << 3;
                            framebuffer.data[dest + 1] = ((color >> 5) & 63) << 2;
                            framebuffer.data[dest + 2] = ((color >> 11) & 31) << 3;
                            framebuffer.data[dest + 3] = 0xff;
                        }
                    }
                }
            }
            ctx.putImageData(framebuffer, 0, 0);
            window.requestAnimationFrame(loop);
        }
    </script>
</body>

</html>
